<!doctype html>
<html>

<meta charset="UTF-8">
<script>
    !function (e, a) { "object" == typeof exports && "undefined" != typeof module ? module.exports = a() : "function" == typeof define && define.amd ? define(a) : (e = e || self).wasmFeatureDetect = a() }(this, (function () { "use strict"; return { bigInt: () => (async e => { try { return (await WebAssembly.instantiate(e)).instance.exports.b(BigInt(0)) === BigInt(0) } catch (e) { return !1 } })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 126, 1, 126, 3, 2, 1, 0, 7, 5, 1, 1, 98, 0, 0, 10, 6, 1, 4, 0, 32, 0, 11])), bulkMemory: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11])), exceptions: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 6, 64, 7, 26, 11, 11])), multiValue: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 0, 2, 127, 127, 3, 2, 1, 0, 10, 8, 1, 6, 0, 65, 0, 65, 0, 11])), mutableGlobals: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 2, 8, 1, 1, 97, 1, 98, 3, 127, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 5, 1, 1, 97, 3, 1])), referenceTypes: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 7, 1, 5, 0, 208, 112, 26, 11])), saturatedFloatToInt: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 12, 1, 10, 0, 67, 0, 0, 0, 0, 252, 0, 26, 11])), signExtensions: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 65, 0, 192, 26, 11])), simd: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11])), tailCall: async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 6, 1, 4, 0, 18, 0, 11])), threads: () => (async e => { try { return (new ("undefined" != typeof MessageChannel ? MessageChannel : await import("worker_threads").then(e => e.MessageChannel))).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e) } catch (e) { return !1 } })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])) } }));
</script>
<script type="text/javascript" src="shellWasmTV.wasm.js"></script>
<script type="text/javascript" src="shellWasmT.wasm.js"></script>
<script type="text/javascript" src="shellWasm.wasm.js"></script>
<script>
    console.log('Started');
    let Module;

    function instantiateModule(M) {
        console.log('Ready', M);
        Module = M;
        //testFull();
        //runFunc();
        runFuncSplit();
    }

    if (typeof wasmFeatureDetect !== 'undefined') {
        console.log('wasmFeatureDetect Working');
        wasmFeatureDetect.threads().then(threadsSupported => {
            wasmFeatureDetect.simd().then(simdSupported => {
                if (threadsSupported) {
                    console.log('threaded');
                    if (simdSupported) {
                        console.log('vectorized');
                        ShellWasmTV().then(instantiateModule);
                    } else {
                        console.log('unvectorized');
                        ShellWasmT().then(instantiateModule)
                    }
                } else {
                    console.log('unthreaded');
                    ShellWasm().then(instantiateModule);
                }
            });
        });
    } else {
        console.log('wasFeatureDetect Not Working');
        console.log('unvectorized');
        ShellWasm().then(instantiateModule)
    }

    const shellData = [
        [.460, 780, .292, 1460, 2574, 6, .033, 76, 45, 60, 0],
        [.220, 995, .2549, 207, 2574, 7, .022, 37, 55, 65, 0]
    ];
    const angles = [10];


    function runFunc() {
        console.log('Entered');
        const numShells = shellData.length;
        const instance = new Module.shellCombined(numShells);
        for (const [i, shell] of shellData.entries()) {
            instance.setValues(...shell, i);
        }

        //console.log(instance);
        instance.calcImpact();
        //instance.printImpact();
        console.log("ran");
        instance.calcAngles(70, -20);
        instance.calcPostPen(70, -20, angles, true, false);

        console.log("ran");
        //instance.printPostPen();

        const testPoints = (instance, num) => {
            for (let i = 0; i < instance.getImpactSize(); i++) {
                console.log(i, instance.getAnglePoint(num, i, Module.angleIndices.distance.value),
                    instance.getAnglePoint(num, i, Module.angleIndices.ra0.value)
                );
            }

            for (let i = 0; i < instance.getImpactSize(); i++) {
                //console.log(i);
                console.log(i, instance.getPostPenPoint(num, i, Module.postPenIndices.distance.value, 0),
                    instance.getPostPenPoint(num, i, Module.postPenIndices.x.value, 0),
                    instance.getPostPenPoint(num, i, Module.postPenIndices.xwf.value, 0)
                );
            }
        }

        const testPointArrays = (instance, num) => {
            console.log(instance.getImpactPointArray(
                num,
                Module.impactIndices.distance.value,
                Module.impactIndices.rawPen.value
            ));

            console.log(instance.getAnglePointArray(
                num,
                Module.angleIndices.distance.value,
                Module.angleIndices.ra0D.value
            ));

            console.log(instance.getPostPenPointArray(
                num, 0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));

            console.log(instance.getPostPenPointArrayFuseStatus(
                num, true, 0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));

            console.log(instance.getPostPenPointArrayFuseStatus(
                num, false, 0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));
        }

        for (let num = 0; num < numShells; num++) {
            testPoints(instance, num);
            //testPointArrays(instance, num);
        }
        instance.delete();
    }
    const runFuncSplit = () => {
        const shells = [];
        const calc = new Module.shellCalc();
        for (const data of shellData) {
            shells.push(new Module.shell(...data, ''));
        }

        for (const shell of shells) {
            calc.calcImpact(shell);
            calc.calcAngles(shell, 70, -20);
            calc.calcPostPen(shell, 70, -20, angles, true, false);
        }

        const testPoints = (shell) => {
            let impactSize = shell.getImpactSize();
            let postpenSize = shell.getPostPenSize();
            for (let i = 0; i < impactSize; i++) {
                console.log(shell.getImpactPoint(i, Module.impactIndices.distance.value),
                    shell.getImpactPoint(i, Module.impactIndices.rawPen.value));
            }
            console.log('done');

            for (let i = 0; i < impactSize; i++) {
                console.log(shell.getAnglePoint(i, Module.angleIndices.distance.value),
                    shell.getAnglePoint(i, Module.angleIndices.ra0D.value));
            }
            console.log('done');

            for (let i = 0; i < postpenSize; i++) {
                console.log(shell.getPostPenPoint(i, Module.postPenIndices.distance.value, 0),
                    shell.getPostPenPoint(i, Module.postPenIndices.x.value, 0),
                    shell.getPostPenPoint(i, Module.postPenIndices.xwf.value, 0));
            }
            console.log('done');
        }

        const testPointArrays = (shell) => {
            console.log(shell.getImpactPointArray(
                Module.impactIndices.distance.value,
                Module.impactIndices.rawPen.value
            ));

            console.log(shell.getAnglePointArray(
                Module.angleIndices.distance.value,
                Module.angleIndices.ra0D.value
            ));

            console.log(shell.getPostPenPointArray(
                0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));

            console.log(shell.getPostPenPointArrayFuseStatus(
                true, 0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));

            console.log(shell.getPostPenPointArrayFuseStatus(
                false, 0,
                Module.postPenIndices.distance.value,
                Module.postPenIndices.x.value
            ));
        }

        for (const shell of shells) {
            //testPoints(shell);
            testPointArrays(shell);
        }
    }
</script>

<body>
    <button type="button" onclick="runFunc()">Test</button>
</body>

</html>